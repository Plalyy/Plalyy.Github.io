<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>H.pair数位DP</title>
    <url>/2020/05/22/H-pair%E6%95%B0%E4%BD%8DDP/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="H-pair-数位DP"><a href="#H-pair-数位DP" class="headerlink" title="H.pair 数位DP"></a>H.pair 数位DP</h3><ul>
<li><p>题意：给定三个整数A,B,C，求数对个数$(1\leq x\leq A,1\leq y\leq B)$,至少满足以下一个条件：</p>
<p>$(x $ $and$ $y)&gt;C$</p>
<p>$(x $ $xor$ $y)&lt;C$</p>
<p>想了好久，转成二进制按位计数，会不会是数位DP，跟杰哥锋哥哥说了下，应该是，然后就去百度学习数位DP了，拉出来不要62的AC代码开始魔改。三维变五维又变七维，最后在锋哥哥的帮助下终于过了。</p>
<p>从高位到低位数位DP，其考虑的范围是$(0\leq x\leq A,0\leq y\leq B)$，跟题目要求不同，要注意这里产生的非法情况，大概两种做法吧：</p>
<a id="more"></a>

<p>1.开五维  $dp[pos][pre1][pre2][lim1][lim2]$ ，pre1表示此前与运算与C的比较关系，lim1表示与运算的临界关系，求出总数 $ans$ , 然后减去 $(min(A,C-1)+min(B,C-1)+1)$，0导致的非法情况只在 $xor$ 中出现，所以保证 $\leq c-1$ 。</p>
<p>2.开七维  $dp[pos][pre1][pre2][lim1][lim2][vis1][vis2]$ ,在五维的基础上增加了 vis 表示该运算中是否添加过非零值，最后只需要统计vis==1的答案。</p>
<p><del>赛时开了七维过的</del>：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">ll a[<span class="number">40</span>],b[<span class="number">40</span>],c[<span class="number">40</span>];</span><br><span class="line">ll A,B,C;</span><br><span class="line">ll dp[<span class="number">40</span>][<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>][<span class="number">5</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">ll <span class="title">dfs</span><span class="params">(ll pos, ll pre1 ,ll pre2 , ll lim1 ,ll lim2, ll vis1, ll vis2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis1&amp;&amp;vis2&amp;&amp;(pre1==<span class="number">1</span>||pre2==<span class="number">1</span>) ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dp[pos][pre1][pre2][lim1][lim2][vis1][vis2] != <span class="number">-1</span>) <span class="keyword">return</span> dp[pos][pre1][pre2][lim1][lim2][vis1][vis2];</span><br><span class="line">    ll up1 = lim1 ? a[pos] : <span class="number">1</span>;</span><br><span class="line">    ll up2 = lim2 ? b[pos] : <span class="number">1</span>;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=up1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=up2;j++)&#123;</span><br><span class="line">            ll dis1=i&amp;j,dis2=i^j;</span><br><span class="line">            ll m1=pre1,m2=pre2;</span><br><span class="line">            <span class="keyword">if</span>(m1==<span class="number">0</span>)&#123; <span class="comment">// &amp;   之等于时判断</span></span><br><span class="line">                <span class="keyword">if</span>(dis1&gt;c[pos]) m1=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dis1&lt;c[pos])m1=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(m2==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis2&lt;c[pos]) m2=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dis2&gt;c[pos]) m2=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans+=dfs(pos<span class="number">-1</span>,m1,m2,lim1&amp;&amp;i==up1,lim2&amp;&amp;j==up2, vis1||i,vis2||j );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[pos][pre1][pre2][lim1][lim2][vis1][vis2] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">-1</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">        <span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="keyword">sizeof</span>(b));</span><br><span class="line">        <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="keyword">sizeof</span>(c));</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;A&gt;&gt;B&gt;&gt;C;</span><br><span class="line">        ll tmp=A;</span><br><span class="line">        <span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            a[cnt++]=tmp%<span class="number">2</span>;</span><br><span class="line">            tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,cnt);</span><br><span class="line">        tmp=B;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            b[cnt++]=tmp%<span class="number">2</span>;</span><br><span class="line">            tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;mx=<span class="built_in">max</span>(mx,cnt);</span><br><span class="line">        tmp=C;</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            c[cnt++]=tmp%<span class="number">2</span>;</span><br><span class="line">            tmp&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mx=<span class="built_in">max</span>(mx,cnt);</span><br><span class="line">        ll ans=dfs(mx,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//初始化比较关系为0</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>今天总体还算可以，C题我溜去上课耽误了一点时间，等会补下线段树的做法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello</title>
    <url>/2020/05/13/Hello/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>为什么开一个这样的东西？</p>
<p>很多次想百度解决问题，结果大多都是复制来复制去，甚至复制的会是错的，想整理自己的问题以及解决方式，希望有点用吧。</p>
<p>另一方面，想记下来一点东西吧，这样更有意思点？</p>
<p>还有别的因素，想不到了。</p>
<hr>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>XIU-微信小程序</title>
    <url>/2020/06/15/XIU-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="微信小程序比赛提交过作品了，这里简单回顾一下。"><a href="#微信小程序比赛提交过作品了，这里简单回顾一下。" class="headerlink" title="微信小程序比赛提交过作品了，这里简单回顾一下。"></a>微信小程序比赛提交过作品了，这里简单回顾一下。</h3><p>XIU 修小善  校园维修助手</p>
<p>核心基本是订单的增删改查，地址管理，还加了点别的功能</p>
<p>感谢三位队友</p>
<hr>
<p>之前看到微信小程序大赛的广告，想着给mm做一个挺不错，那要不先搞一下这个积累点经验？ </p>
<p>我转发给了外校的高ZK，他又拉了两个学长Y和C，组成了队伍。这个组队的效率真的蛮高的，然后当天的晚上，我们就基本确定了方向以及分工，做一个校内电子产品维修类的小程序，灵感来自于Y学长在校期间曾在电子社团张罗过类似的事。我和C学长负责一下交互还有数据库相关的，高负责页面，Y学长统筹。</p>
<a id="more"></a>

<p>高写页面真的厉害的，两位学长也很强，我也算是学到了点东西吧，不过更多就是调参？感觉没有硬功底，非要说的话，也就是带着写了写页面，去简单学了一下JS，锻炼了下耐心。</p>
<p>眨眼几个月过去了，Y学长搞完毕设就业了，C学长忙完实验室准备考研，高也准备跨考计算机，我呢还挺迷茫的，还是先做好眼下的事。说来这个东西也不难的，一个小东西，但最后还是挺有成就感的，最后几天几个人疯狂调bug，大家都辛苦啦，而且每个人都蛮负责的。</p>
<p>然后就是再修修页面功能，等下一步结果咯。</p>
<h3 id="遇到的问题，记下来"><a href="#遇到的问题，记下来" class="headerlink" title="遇到的问题，记下来"></a>遇到的问题，记下来</h3><h4 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h4><p>记得加decode就好了</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">decode</span>=<span class="string">'true'</span>&gt;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="获取系统时间"><a href="#获取系统时间" class="headerlink" title="获取系统时间"></a>获取系统时间</h4><p>系统自带的 utils.js 其实已经有蛮好的功能了，方便统一按格式获取年月日的话可以自己写个函数。如果选择自己写，一定要记得开放端口。关于页面中调用函数，之前翻了很多博客，搬上去之后都在报错 data undefined，博客下面相关地提问也没有回复，再细看，原来那么多博客都是抄地同一篇啊，怪不得报错都是一模一样的。</p>
<p>然后就索性自己凑个数据格式，不要函数了？</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">	<span class="attribute">onLoad</span>: <span class="function"><span class="keyword">function</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">var</span> timestamp=<span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">		<span class="keyword">var</span> <span class="built_in">date</span>=<span class="keyword">new</span> <span class="built_in">Date</span>(timestamp)</span><br><span class="line">		<span class="keyword">var</span> Y=<span class="built_in">date</span>.getFullYear();        <span class="comment">//需要对齐时加个三目运算就好</span></span><br><span class="line">		<span class="keyword">var</span> M=<span class="built_in">date</span>.getMonth()+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">var</span> D=<span class="built_in">date</span>.getDate(); </span><br><span class="line">		<span class="keyword">var</span> hour=<span class="built_in">date</span>.getHours()</span><br><span class="line">		<span class="keyword">var</span> minute=<span class="built_in">date</span>.getMinutes()</span><br><span class="line">		<span class="keyword">var</span> second=<span class="built_in">date</span>.getSeconds()</span><br><span class="line">		<span class="keyword">this</span>.setData(&#123;</span><br><span class="line">   			<span class="attribute">time</span>: Y+<span class="string">'年'</span>+M+<span class="string">'月'</span>+D+<span class="string">'日 '</span>+hour+<span class="string">':'</span>+minute+<span class="string">':'</span>+second</span><br><span class="line">   		&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h4><h5 id="1-页面简单传值"><a href="#1-页面简单传值" class="headerlink" title="1.页面简单传值"></a>1.页面简单传值</h5><p>可以传一个参数或多个参数，不过要传集合的话，要么是拆参数传，要么是转成字符串传，不过转成字符串好像稍微有点麻烦，还不如用其他方式传值。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假设A-&gt;B 传递index</span></span><br><span class="line"><span class="comment">//A页面中</span></span><br><span class="line"><span class="selector-tag">wx</span><span class="selector-class">.navigateTo</span>(&#123; </span><br><span class="line">	<span class="attribute">url</span>: <span class="string">'../B/B?index=index'</span>  <span class="comment">//  '../B/B?index='+index</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//B页面中</span></span><br><span class="line"><span class="attribute">onLoad</span>: function(option)&#123;</span><br><span class="line">	this.setData(&#123;</span><br><span class="line">		<span class="attribute">index</span>: option.index  <span class="comment">//要提前定义 index</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传多个值也是同样的，在后面 &amp;&amp; 继续加数据就好</p>
<h5 id="2-回退页面传值"><a href="#2-回退页面传值" class="headerlink" title="2.回退页面传值"></a>2.回退页面传值</h5><p>感觉这个好精彩，可以直接对页面栈中上个页面进行操作</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pages = getCurrentPages();</span><br><span class="line">   <span class="keyword">var</span> currPage = pages[pages.length<span class="number">-1</span>]; <span class="comment">//当前页面</span></span><br><span class="line">   <span class="keyword">var</span> prevPage = pages[pages.length<span class="number">-2</span>]; <span class="comment">//上个页面</span></span><br><span class="line">   prevPage.setData(&#123;</span><br><span class="line">     	<span class="keyword">value</span>: <span class="keyword">this</span>.data.<span class="keyword">value</span>,</span><br><span class="line">   &#125;)</span><br><span class="line">   wx.navigateBack(&#123;</span><br><span class="line">      	delta : <span class="number">1</span>,</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-本地存储传值"><a href="#3-本地存储传值" class="headerlink" title="3.本地存储传值"></a>3.本地存储传值</h5><p>这个之前写的有点乱了，之后加上去吧。</p>
<h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>尤其在 wx:for 遍历时，之前有的方法还会出错，就统一改成 data-XXX了，这个应该是简单的绑定了吧。</p>
<p>对了，要注意这样绑定是 currentTarget .</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//wxml:</span></span><br><span class="line">&lt;view data-index=<span class="string">"&#123;&#123;index&#125;&#125;"</span> bindtap=<span class="string">"To"</span> &gt;&lt;/view&gt;</span><br><span class="line"><span class="comment">//js:</span></span><br><span class="line"><span class="function"><span class="title">To</span><span class="params">(e)</span></span>&#123;</span><br><span class="line">	<span class="selector-tag">var</span> In = e<span class="selector-class">.currentTarget</span><span class="selector-class">.dataset</span>.index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>咕咕咕。。。</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
  </entry>
  <entry>
    <title>最近题目</title>
    <url>/2020/05/21/%E6%9C%80%E8%BF%91%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="0-最近"><a href="#0-最近" class="headerlink" title="0.最近"></a>0.最近</h3><p>前几天比赛挺多的，也挺自闭，补题有点慢了，尤其那个线段树专场搞的我有点崩溃，让自己怀疑是不是这块的料，还是好好调整下心态吧。</p>
<h3 id="1-焦作站B题"><a href="#1-焦作站B题" class="headerlink" title="1.焦作站B题"></a>1.焦作站B题</h3><p><a href="https://codeforces.com/gym/102028/problem/B" target="_blank" rel="noopener">B. Ultraman vs. Aodzilla and Bodzilla</a></p>
<ul>
<li><p>题意：作为勇士的锋gg要跟怪兽A、B进行回合式战斗，锋gg每次只能攻击一只怪兽但被两只怪兽攻击，锋gg第 $i$ 回合的伤害为 $i $，请给出最优的攻击序列，要求使锋gg受到最小的伤害且同样伤害的情况下序列的字典序最小。</p>
</li>
<li><p><del>比赛的时候李哥还是锋gg读了一下题，然后我们就没来得及做了。</del></p>
</li>
<li><p>回合式战斗要想受到最小的伤害，一是优先解决部分怪兽，二是尽可能快速解决战斗。所以分为优先解决A还是B两种情况，然后保证回合数最小。先预处理下伤害值 sum[ ] ，因为每天的伤害值是公差为1的等差数列，所以根据lower_bound( HA+HB )确定回合数一定是最优的回合数，不受伤害溢出之类情况的影响，然后具体分析。</p>
<a id="more"></a>
</li>
<li><p>1.先解决A，lower(HA)获得解决A的回合数，并做差得到解决A时的溢出伤害 $dis$。判断剩下的回合数是否可以解决掉B。如果可以，直接根据回合数输出序列，否则假设某一回合的伤害等于溢出的伤害，就可以把该伤害分给B，两只怪兽都可以解决。</p>
<blockquote>
<p>只把溢出的伤害全部分给B，所以需要单独的一个回合</p>
</blockquote>
</li>
<li><p>2.先解决B，lower(HB)获得解决B的回合数，并做差得到解决B时的溢出伤害 $dis$。根据upper(dis) - 1可以得到保证能解决B的同时能去掉的最长前缀，由这个前缀产生的伤害可以转移给A（注意：该伤害 $\leq$ 解决B的溢出伤害）。判断该伤害以及解决B之后的后续伤害能否解决A，如果可以则前缀为攻击A，然后攻击B，最后攻击A。否则做差得到处理怪兽A还需要的伤害 $tis$, 在处理B时，假如 $tis\geq2i+1 || tis==i$，可以当前回合攻击B。</p>
<blockquote>
<p>如果想让字典序尽可能小，则先考虑A放在最前的情况是否成立，此时补偿给A的伤害 $\leq$ 处理B溢出伤害。如果不成立，就根据A需要的伤害，尽可能往前面插。</p>
<blockquote>
<p>注意不能影响处理B，所以取最长前缀的时候 用的是 upper - 1</p>
</blockquote>
</blockquote>
</li>
<li><p>两种情况的伤害值容易得出，然后根据伤害值和字典序比较就好了。（讲乱了）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200020</span>;</span><br><span class="line"><span class="keyword">int</span> sum[N];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">100020</span>;i++)&#123;</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> HA,HB,KA,KB;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;HA&gt;&gt;HB&gt;&gt;KA&gt;&gt;KB;</span><br><span class="line">        <span class="built_in">string</span> ans1,ans2;</span><br><span class="line">        <span class="comment">//A</span></span><br><span class="line">        <span class="keyword">int</span> t1=lower_bound(sum+<span class="number">1</span>,sum+<span class="number">100000</span>,HA)-sum;</span><br><span class="line">        <span class="keyword">int</span> t2=lower_bound(sum+<span class="number">1</span>,sum+<span class="number">100000</span>,HA+HB)-sum;</span><br><span class="line">        <span class="keyword">int</span> sum1=t1*KA+t2*KB;</span><br><span class="line">        <span class="keyword">if</span>(sum[t2]-sum[t1]&gt;=HB)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t1;i++)    ans1+=<span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t1+<span class="number">1</span>;i&lt;=t2;i++) ans1+=<span class="string">'B'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dis=sum[t1]-HA;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t1;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=dis) ans1+=<span class="string">'A'</span>;</span><br><span class="line">                <span class="keyword">else</span> ans1+=<span class="string">'B'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t1+<span class="number">1</span>;i&lt;=t2;i++) ans1+=<span class="string">'B'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B</span></span><br><span class="line">        <span class="keyword">int</span> t3=lower_bound(sum+<span class="number">1</span>,sum+<span class="number">100000</span>,HB)-sum;</span><br><span class="line">        <span class="keyword">int</span> sum2=KB*t3+KA*t2;</span><br><span class="line">        <span class="keyword">int</span> di=sum[t3]-HB;</span><br><span class="line">        <span class="keyword">int</span> t4=upper_bound(sum+<span class="number">1</span>,sum+<span class="number">100000</span>,di)-sum<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum[t4]+sum[t2]-sum[t3]&gt;=HA)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t4;i++)    ans2+=<span class="string">'A'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t4+<span class="number">1</span>;i&lt;=t3;i++) ans2+=<span class="string">'B'</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t3+<span class="number">1</span>;i&lt;=t2;i++) ans2+=<span class="string">'A'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> dd = HA-(sum[t2]-sum[t3]);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t3;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dd&gt;=<span class="number">2</span>*i+<span class="number">1</span>||dd==i)&#123;</span><br><span class="line">                    dd-=i,ans2+=<span class="string">'A'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> ans2+=<span class="string">'B'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=t3+<span class="number">1</span>;i&lt;=t2;i++)&#123;</span><br><span class="line">                ans2+=<span class="string">'A'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum1&lt;sum2) <span class="built_in">cout</span>&lt;&lt;sum1&lt;&lt;<span class="string">" "</span>&lt;&lt;ans1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum1&gt;sum2) <span class="built_in">cout</span>&lt;&lt;sum2&lt;&lt;<span class="string">" "</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans1&lt;ans2) <span class="built_in">cout</span>&lt;&lt;sum1&lt;&lt;<span class="string">" "</span>&lt;&lt;ans1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;sum2&lt;&lt;<span class="string">" "</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<h3 id="2-美团杯"><a href="#2-美团杯" class="headerlink" title="2.美团杯"></a>2.美团杯</h3><p>美团杯没有打，赛后试着做了一下，让我打的话估计只能拿small了。</p>
<ul>
<li><p>A题之前好像见过类似的，不过自己处理的还是有点问题，看了锋gg写的，dp这块还得多做下题。</p>
</li>
<li><p>图片解密，看完small，excel设置下条件格式就出来了，large就无力了，想起来CF愚人节场那个判断里外的，python好香啊。</p>
</li>
<li><p>魔塔真的好好玩，想起来小时候跟我哥对着电脑各种搞，是男人就***，是童年的感觉了，不过这道题还是离100层遥遥无期啊，small倒是挺简单的。</p>
</li>
<li><p>交互题只能过small，记得之前CF有道交互题，你每次选一个序列，能获得目标值在这个序列中的排名，经过*次问你是否能得到原序列还是目标值总排名。所以这道题每次选两个，确定一下排名关系。前些天好像有个学弟问C语言的题，也用到了这个思路。看了别人写的题解，stable_sort学到了，归并排序我之前也只会求个逆序对。</p>
</li>
</ul>
<h3 id="3-CF"><a href="#3-CF" class="headerlink" title="3.CF"></a>3.CF</h3><p>这几场CF暴露出来的问题挺大的，树状数组用的不熟，二分三分做的也不好，多理解多练习一下吧。还有之前看到CF图论板块挺好的，平时做做记录一下。</p>
<blockquote>
<p>什么时候才能跟锋gg一样上紫啊</p>
</blockquote>
<h3 id="4-期末考试"><a href="#4-期末考试" class="headerlink" title="4.期末考试"></a>4.期末考试</h3><p>还有六门课，概率论和计组好像学的都不怎么好，得好好学一下了。</p>
<h3 id="5-杂谈"><a href="#5-杂谈" class="headerlink" title="5.杂谈"></a>5.杂谈</h3><p>修改博客文档时发现渲染失败，后来知道 .yml 文件，以及设置的post模板中出现的冒号后均要加空格。</p>
<p>多组数据一定要考虑memset的问题</p>
<p>添加音乐播放器，但播放异常的问题还没有解决</p>
<p>gitalk感觉不太好用，改用valine,邮件自动提醒正在配</p>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>序列自动机</title>
    <url>/2020/06/12/%E5%BA%8F%E5%88%97%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>补题，学一下序列自动机，看了 <a href="https://blog.csdn.net/weixin_30568715/article/details/96500133?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">序列自动机总结与例题</a></p>
<p>说白了就是一个二维数组 $nxt[i][j]$ ，对于字符集 $a$, $|s|=n$ , $nxt[i][j]$表示$i$ 以后第一个字符 $j$ 的位置，0为根节点，建图即 $DAG$ 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n ; i &gt;= <span class="number">1</span> ; i ++ )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j= <span class="number">1</span> ; j &lt;= a ; j ++ )&#123;</span><br><span class="line">        nxt[i<span class="number">-1</span>][j] = nxt[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    nxt[i<span class="number">-1</span>][s[i]] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以想到的用处：</p>
<p>​        1.判断是否是原字符串的子序列</p>
<p>​        2.求子序列个数</p>
<p>​        3.求两串的公共子序列个数</p>
<p>​        4.求串的回文子序列个数</p>
<p>​        5.求一个$A,B$的最长公共子序列$S$，使得$C$是的子序列</p>
<p>//代码还没搬上来</p>
<a id="more"></a>

<p>先贴一道遇到的题吧</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6586" target="_blank" rel="noopener">HDU 2019 多校 - String</a></p>
<p>题意：给定字符串 $s$, 找出长度为 $k$ 且字典序最小的子序列，要满足每个字母出现的次数在范围$[Li,Ri]$内，否则输出 -1。</p>
<p>分析：当时想着不太会贪心，暴力点就是遍历k个位置，每个位置优先去放字典序小的，且能使得满足L,R的字符。判断能否放置的时候要考虑到后续的情况。具体考虑就用到了上述的序列自动机的思想（其实就是记录每个字符下个出现的位置），可以预处理二维next数组，也可以开vector存每种字符的出现位置+迭代器，感觉后者更舒服？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="built_in">string</span> st;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">100020</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">100020</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> res[<span class="number">100020</span>];</span><br><span class="line"><span class="keyword">int</span> L[<span class="number">30</span>],R[<span class="number">30</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;Q[<span class="number">30</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;st&gt;&gt;k)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;L[i]&gt;&gt;R[i];</span><br><span class="line">            Q[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = st.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                cnt[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;  <span class="comment">//后缀</span></span><br><span class="line">                cnt[i][j]=cnt[i+<span class="number">1</span>][j]+(st[i]==(<span class="string">'a'</span>+j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            Q[st[i]-<span class="string">'a'</span>].push_back(i);<span class="comment">// 位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;::iterator dis[<span class="number">26</span>];<span class="comment">//头指针</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) dis[i]=Q[i].<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">-1</span>,last=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123; <span class="comment">//遍历k个位置</span></span><br><span class="line">            <span class="keyword">int</span> flag1=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">26</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(vis[j]==R[j]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">while</span>(dis[j]!=Q[j].<span class="built_in">end</span>()&amp;&amp;( (*dis[j])&lt;=last)) </span><br><span class="line">                    dis[j]++; </span><br><span class="line">                <span class="keyword">if</span>(dis[j]==Q[j].<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                vis[j]++;</span><br><span class="line">                <span class="comment">//假设该位放 j ，之后判断不满足情况</span></span><br><span class="line">                <span class="keyword">int</span> pos=*dis[j],sum1=<span class="number">0</span>,sum2=<span class="number">0</span>,flag=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> t=<span class="number">0</span>;t&lt;<span class="number">26</span>;t++)&#123;                    <span class="comment">//三种情况</span></span><br><span class="line">                    <span class="keyword">if</span>(cnt[pos+<span class="number">1</span>][t]+vis[t]&lt;L[t]) flag=<span class="number">0</span>; <span class="comment">//不能达到L</span></span><br><span class="line">                    sum1+=<span class="built_in">max</span>(L[t]-vis[t],<span class="number">0</span>);             <span class="comment">//距离L的总差距</span></span><br><span class="line">                    sum2+=<span class="built_in">min</span>(cnt[pos+<span class="number">1</span>][t],R[t]-vis[t]); <span class="comment">//剩下合法个数</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(sum1&gt;k-i<span class="number">-1</span>||sum2&lt;k-i<span class="number">-1</span>) flag=<span class="number">0</span>;        <span class="comment">//剩下数量不足</span></span><br><span class="line">                <span class="keyword">if</span>(!flag) vis[j]--;                       <span class="comment">//当前不能使用</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i]=<span class="string">'a'</span>+j;</span><br><span class="line">                    flag1=<span class="number">1</span>;</span><br><span class="line">                    last=pos;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag1)&#123;                                  <span class="comment">//当前位无法放置</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">                ans=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans==<span class="number">-1</span>)&#123;</span><br><span class="line">            res[k]=<span class="string">'\0'</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>树形DP-树上点最远距离</title>
    <url>/2020/07/11/%E6%A0%91%E5%BD%A2DP-%E6%A0%91%E4%B8%8A%E7%82%B9%E6%9C%80%E8%BF%9C%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>仍然在往门里钻 , 写题解是希望重新审视一下细节，可能有亿点点乱。</p>
<ul>
<li><h4 id="POJ-2196-Computer"><a href="#POJ-2196-Computer" class="headerlink" title="POJ 2196 Computer"></a>POJ 2196 Computer</h4></li>
</ul>
<p>题意：一棵树，对于每个结点求出其他点与它最远的距离。</p>
<p>之前做最远距离时，利用的是树的直径，这次看到该题，发现树形DP也不失为一个好办法，所以想了树形DP的解法。某点的最长距离，很容易想到是到其子树最长距离+该点为根时另外子树最远距离。</p>
<p>所以设 $dp[i][j],1\leq i\leq n,j=0,1$ , j 的值表示上述两种子树的状态。</p>
<p>原子树深度由常规的dfs就可以求出，借下来考虑如何求另外部分。所指的另外部分，如下图，也就是该节点父结点及其另外部分，因而，该点的 $dp[2][1]$可以由父结点更新。</p>
<a id="more"></a>

<img src="/2020/07/11/%E6%A0%91%E5%BD%A2DP-%E6%A0%91%E4%B8%8A%E7%82%B9%E6%9C%80%E8%BF%9C%E8%B7%9D%E7%A6%BB/1.png" style="zoom:33%;">



<p>结合下图，由结点1，其两个子树的最长距离分别为2，1，最长距离对应的子树结点是2和5。考虑孩子结点         2，因为它唯一满足2的结点本身，所以只能用$dp[2][1]=1+dis[2][1]$ =2，同理 $dp[5][1]=2+dis[5][1]=3$。</p>
<img src="/2020/07/11/%E6%A0%91%E5%BD%A2DP-%E6%A0%91%E4%B8%8A%E7%82%B9%E6%9C%80%E8%BF%9C%E8%B7%9D%E7%A6%BB/2.png" style="zoom:33%;">

<p>说的有点乱了，意思就是目标结点本身就是最远距离满足情况的话，只能用不被占用的次远情况更新它。而且当父结点非根结点的时候，还要考虑$dp[fa][1]$的影响。如下图，还要考虑$dp[1][1]=2$ 是否影响最大值。</p>
<img src="/2020/07/11/%E6%A0%91%E5%BD%A2DP-%E6%A0%91%E4%B8%8A%E7%82%B9%E6%9C%80%E8%BF%9C%E8%B7%9D%E7%A6%BB/3.png" style="zoom:33%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="built_in">vector</span>&lt;pii&gt; Q[<span class="number">10020</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10020</span>][<span class="number">2</span>]; </span><br><span class="line"><span class="comment">//dp[i][0] 为子树最远距离 </span></span><br><span class="line"><span class="comment">//dp[i][1] 为非子树最远距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a=Q[x][i].first;</span><br><span class="line">		<span class="keyword">int</span> b=Q[x][i].second;</span><br><span class="line">		<span class="keyword">if</span>(a==fa) <span class="keyword">continue</span>;</span><br><span class="line">		dp[x][<span class="number">0</span>]=<span class="built_in">max</span>(dp[x][<span class="number">0</span>],dfs1(a,x)+b);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.最大值 2.不是最大值</span></span><br><span class="line">	<span class="keyword">int</span> mx1=<span class="number">0</span>,mx2=<span class="number">0</span>,v1=<span class="number">0</span>,v2=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a=Q[x][i].first;</span><br><span class="line">		<span class="keyword">int</span> b=Q[x][i].second;</span><br><span class="line">		<span class="keyword">if</span>(a==fa||a==x) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp=dp[a][<span class="number">0</span>]+b; <span class="comment">//a子树的最长距离</span></span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;mx1)&#123;</span><br><span class="line">			mx2=mx1,v2=v1;</span><br><span class="line">			mx1=tmp,v1=a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tmp==mx1||tmp&gt;mx2)&#123;</span><br><span class="line">			mx2=tmp,v2=a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//用其他子树更新</span></span><br><span class="line">	<span class="keyword">if</span>(x!=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp=dp[x][<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span> a=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;mx1)&#123;</span><br><span class="line">			mx2=mx1,v2=v1;</span><br><span class="line">			mx1=tmp,v1=a;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(tmp==mx1||tmp&gt;mx2)&#123;</span><br><span class="line">			mx2=tmp,v2=a;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a=Q[x][i].first;</span><br><span class="line">		<span class="keyword">int</span> b=Q[x][i].second;</span><br><span class="line">		<span class="keyword">if</span>(a==fa||a==x) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(a==v1)&#123;</span><br><span class="line">			dp[a][<span class="number">1</span>]=mx2+b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			dp[a][<span class="number">1</span>]=mx1+b;</span><br><span class="line">		&#125;</span><br><span class="line">		dfs2(a,x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) Q[i].<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> a,b;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">			Q[a].push_back(&#123;i,b&#125;);</span><br><span class="line">			Q[i].push_back(&#123;a,b&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">		dfs1(<span class="number">1</span>,<span class="number">-1</span>); <span class="comment">//获得子树最远距离</span></span><br><span class="line">		dfs2(<span class="number">1</span>,<span class="number">-1</span>); <span class="comment">//获得非子树最远距离</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>删数求前缀-奇怪的名字</title>
    <url>/2020/07/09/%E5%88%A0%E6%95%B0%E6%B1%82%E5%89%8D%E7%BC%80-%E5%A5%87%E6%80%AA%E7%9A%84%E5%90%8D%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://vjudge.net/contest/381578#problem/G" target="_blank" rel="noopener">HDU2019多校第三场 G - Find the answer</a></p>
<p>题意：给定长为n的序列以及整数m，对于位置 i ，可以令 k (k &lt; i)位置的数变为0，使得这段前缀和小于等于m，求每个位置的最小改变数。</p>
<p>分析：求最小改变数，也就是尽可能多使用原数，搞一个multiset和一个sum，处理一下进出元素。multiset存可以使用的元素，sum为堆中元素贡献。假如sum+a[i]&lt;=m，插入元素，否则从堆里开始假删除（后面每次是独立的，不能影响后续），当满足合法后若a[i]&lt;max，那么将两个元素互换，很显然次数不变的情况下sum越小越好。同理，用线段树维护子集也可以。</p>
<p>必须要有n个空格+换行！不然PE</p>
<p>CF #568 Div.2小数据题  <a href="https://codeforces.com/contest/1185/problem/C2" target="_blank" rel="noopener">C2. Exam in BerSU (hard version)</a></p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;pq;</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                ans[i]=<span class="number">0</span>;</span><br><span class="line">                pq.insert(a[i]);</span><br><span class="line">                sum=a[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum+a[i]&lt;=m)&#123;</span><br><span class="line">                pq.insert(a[i]);</span><br><span class="line">                ans[i]=i-pq.<span class="built_in">size</span>()+<span class="number">1</span>;</span><br><span class="line">                sum+=a[i];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> pis=pq.<span class="built_in">end</span>();</span><br><span class="line">            pis--;</span><br><span class="line">            <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">            ll tmp=sum;</span><br><span class="line">            <span class="keyword">while</span>(tmp+a[i]&gt;m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//开始删除</span></span><br><span class="line">                tmp-=*pis,num++;</span><br><span class="line">                <span class="keyword">if</span>(tmp+a[i]&lt;=m)&#123;</span><br><span class="line">                   <span class="comment">//</span></span><br><span class="line">                    ans[i]=i-pq.<span class="built_in">size</span>()+num;</span><br><span class="line">                    <span class="keyword">auto</span> pp =pq.<span class="built_in">end</span>();</span><br><span class="line">                    pp--;</span><br><span class="line">                    <span class="keyword">if</span>(a[i]&lt;*pp)&#123;</span><br><span class="line">                        sum=sum+a[i]-*pp;</span><br><span class="line">                        pq.insert(a[i]);</span><br><span class="line">                        pq.erase(pp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pis--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>题解</category>
      </categories>
  </entry>
  <entry>
    <title>树形DP入门题</title>
    <url>/2020/07/11/%E6%A0%91%E5%BD%A2DP%E5%85%A5%E9%97%A8%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之前遇到的树形DP，做的都不清楚，重新入下门，希望成功。</p>
<p>挑几道例题入门，太过类似的就算了</p>
<ul>
<li><h4 id="POJ-2342-没有上司的舞会"><a href="#POJ-2342-没有上司的舞会" class="headerlink" title="POJ 2342 没有上司的舞会"></a>POJ 2342 没有上司的舞会</h4><p>题意：公司成员参加舞会，每人都有一个快乐值，成员和直属上司不能同时参加，问如何使得快乐值最大。</p>
<p>显然$dp[i][j]$表示成员 $i$子树(参加与否)达到的最大值。</p>
<p>$dp[i][0]=\sum max(dp[j][1],dp[j][0])$, j 为子成员</p>
<p>$dp[i][1]=\sum dp[j][0]$, j 为子成员</p>
<p>从根节点开始。</p>
<a id="more"></a>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">6020</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span> &gt;Q[<span class="number">6020</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">6020</span>][<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		dfs(Q[x][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Q[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> j=Q[x][i];</span><br><span class="line">		dp[x][<span class="number">0</span>]+=<span class="built_in">max</span>(dp[j][<span class="number">0</span>],dp[j][<span class="number">1</span>]);</span><br><span class="line">		dp[x][<span class="number">1</span>]+=dp[j][<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!n)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;dp[i][<span class="number">1</span>];</span><br><span class="line">			Q[i].<span class="built_in">clear</span>();</span><br><span class="line">			dp[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">int</span> u,v;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">			Q[v].push_back(u);</span><br><span class="line">			fa[u]=v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(fa[i]==<span class="number">0</span>)&#123;</span><br><span class="line">				dfs(i);</span><br><span class="line">				<span class="built_in">cout</span>&lt;&lt;<span class="built_in">max</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">1</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><h4 id="P2015-二叉苹果树"><a href="#P2015-二叉苹果树" class="headerlink" title="P2015 二叉苹果树"></a>P2015 二叉苹果树</h4><p>题意：一棵苹果树，若有分支一定是二叉，树根一定是1，每条边有苹果数，问保留Q根树枝，能留下最多的苹果数量。</p>
<p>分析一下，若想留下某根树枝，则其到根结点路经上的所有边也要保留，所以可以根据子结点更新父结点。而这道题是保留Q根树枝，每个子树的保留树枝都可以更改，所以再加一个简单的01背包，构成状态转移。$dp[i][j]$表示以 $i$ 为结点保留 $j$ 条边的最大苹果数。</p>
<p>​            $dp[x][j]=max(dp[x][j],dp[x][j-k-1]+dp[i][k]+cost[x][i])$</p>
<p>​                $j\leq min(cnt[x],Q),k\leq min(j-1,cnt[k])$</p>
<p>要注意的是在父结点和子节点状态转移时，两者之间必须有边，因而是$j-k-1$ 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">200</span>];</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> ma[<span class="number">120</span>][<span class="number">120</span>];</span><br><span class="line"><span class="keyword">int</span> cost[<span class="number">120</span>][<span class="number">120</span>];</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">120</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">120</span>][<span class="number">120</span>]; <span class="comment">// 结点i 边数为j</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ; i&lt;=n ; i++ )&#123;</span><br><span class="line">		<span class="keyword">if</span>(ma[x][i]&amp;&amp;i!=x&amp;&amp;i!=fa)&#123;</span><br><span class="line">			dfs(i,x);</span><br><span class="line">			cnt[x]+=cnt[i]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="built_in">min</span>(cnt[x],q);j;j--)&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="built_in">min</span>(j<span class="number">-1</span>,cnt[i]);k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">					dp[x][j]=<span class="built_in">max</span>(dp[x][j],dp[x][j-k<span class="number">-1</span>]+dp[i][k]+cost[x][i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a,b,c;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">		ma[a][b]=ma[b][a]=<span class="number">1</span>;</span><br><span class="line">		cost[a][b]=c;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;dp[<span class="number">1</span>][q]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>异或前缀和</title>
    <url>/2020/07/11/%E5%BC%82%E6%88%96%E5%89%8D%E7%BC%80%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>之后更新部分异或/前缀和的题目。</p>
<ul>
<li><h4 id="小AA的数列"><a href="#小AA的数列" class="headerlink" title="小AA的数列"></a>小AA的数列</h4></li>
</ul>
<p>题意：求数列所有长度为偶数且在$[L,R]$之间的区间异或和之和</p>
<p>显然是异或前缀，按位算贡献，问题是如何处理偶数长度和区间限制。然后开始找规律，首先$sum[R-L]=sum[R]\bigoplus sum[L-1]$，针对二进制每位，当前位值为1时，要找此前位为0的数，为0时同理，这样才能产生贡献。所以针对位值，有一个取反的规律，而针对下标，同奇同偶。所以考虑针对每一个右端点，记录此前产生的贡献，并更新贡献。</p>
<a id="more"></a>

<p>接下来考虑如何记录和更新，L和R为奇数时可以调整为偶数，因而从$j==L$开始枚举，每次固定长度$L$进行更新，即对$j-L$的位置贡献加1，然后答案加上满足的贡献。当$j&gt;=R$时，$j-R$的贡献要减1，因为不可能在计算到该位置。</p>
<p>至于固定长度为$L$，在枚举右端点的时候，是可以覆盖到所有左端点的情况的，能更新所有满足的贡献值，所以无需再枚举长度。</p>
<p>总结来说，就是根据位值的0/1和下标的0/1去更新以及计算状态，用$dp[i][j]$，表示前缀中位值为$i$，下标奇偶性为$j$的状态数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> ll mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">ll a[<span class="number">100020</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">	<span class="built_in">cin</span>.tie(<span class="number">0</span>),<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,L,R;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;L&gt;&gt;R;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">		a[i]^=a[i<span class="number">-1</span>];    <span class="comment">//异或前缀</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(L&amp;<span class="number">1</span>) L++;         <span class="comment">//调整区间</span></span><br><span class="line">	<span class="keyword">if</span>(R&amp;<span class="number">1</span>) R--;</span><br><span class="line">	<span class="keyword">if</span>(L&gt;R)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">		ll p =(<span class="number">1l</span>l&lt;&lt;i);</span><br><span class="line">		ll dp[<span class="number">2</span>][<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">		ll num=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=L;j&lt;=n;j++)&#123;</span><br><span class="line">			dp[(a[j-L]&gt;&gt;i)&amp;<span class="number">1</span>][(j-L)&amp;<span class="number">1</span>]++;   <span class="comment">//记录贡献</span></span><br><span class="line">			num+=dp[((a[j]&gt;&gt;i)&amp;<span class="number">1</span>)^<span class="number">1</span>][j&amp;<span class="number">1</span>];  <span class="comment">//位值取反、奇偶性相同</span></span><br><span class="line">			num%=mod;</span><br><span class="line">			<span class="keyword">if</span>(j&gt;=R)&#123;</span><br><span class="line">				dp[(a[j-R]&gt;&gt;i)&amp;<span class="number">1</span>][(j-R)&amp;<span class="number">1</span>]--;<span class="comment">//对长度超限的减掉贡献</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=num*p%mod;</span><br><span class="line">		ans%=mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>随便说说</title>
    <url>/2020/05/27/%E9%9A%8F%E4%BE%BF%E8%AF%B4%E8%AF%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>UPD 5-31: 昨晚梦到在禁区前，用很难想到的熟练度勾回了球并借势踢了一脚，但还是绵软无力。其实可以跟上再补射的，但梦里我静止看着球的轨迹，它好歹是进了。球踢出去，其实还是自己的，有跟上的可能，你总是要跟的。前几天说的以下，部分是短暂的想法，这不，几天时间就又改了。好好努力，好好前进，还有又想回绿茵了。</p>
</blockquote>
<p><strong>最近有点崩，好像是全方面的。</strong></p>
<p>春季学期，念着冬季的复习，吐槽着当前的课程，就这样一直拖到了现在。大概想想，就知道自己确确实实浪费了好多时间，做了很多无营养的事，计组一点都不会，离散数据结构靠灵感，概率论靠那么一点底子，英语没达到之前的初衷，炒股课也是水了过去，日本文学名篇也没沉下心看过几本书。</p>
<p>随便说点想法吧。</p>
<a id="more"></a>

<p>我适合读书吗？有时候会这样想，一如我高三时的想法。是不是坚持完这段时间就好了啊，这样说我不想读研了。</p>
<p>但事实是读书的问题吗？平时的事情越来越不操心，越来越没有危机感，偶尔来的紧张也是去散播忧虑，照样如我高三时的所作所为。全凭有时候吊着的一口气，让我不要永远停下来。这样去做，不论做什么都做不好吧？</p>
<p>那该怎么办呢，真的好乱好烦啊，感觉到处都是不满。最近关于线上考试的安排，常常是大家一两个小时讨论，最后一点东西也没得到的结果，常常会因为某些人的发言而烦气，“为什么有这种问题啊？”，这不就是控制下变量，区分对待就好了吗，为什么要每个人要严格按照一个模板来啊，这样问题不是永远解决不了的吗。</p>
<p>或者是有时候会漏掉作业对自己很无语，有时候是做着研讨抄着东西，问我这是在干嘛？很可笑的是大概是一年前的现在我哭着想问一个意义在哪，一年过来了，我似乎给自己找到了一条找意义的路，先做到。以前喜欢士兵突击。发生了很多事情之后用了成才的 “ 我要回去寻找我的枝枝蔓蔓了 ” 当作格言，一年回望，其实我更应该记得 “想要和得到之间还有两个字叫做到 ”，过于纠结目前的和未来的，能有什么结局啊？</p>
<p>在球场上，我也总是畏手畏脚，拿到球后总会乱，我不知道应该怎么处理，初中在小乔的鼓励下进了两个任意球，那好像是我最早相信我喜欢足球的时候。后来刚到一中也是呀，常常跟高年级的人踢球，也可以让B星和季林一脚长传跑到前场单突，一场都可以来上很多次，不知道做什么很乱的时候，就进攻好了啊，我超级享受撕开他们防线然后取得进球的那一刻，我现在还能清清楚楚的记得那些个不容易的进球的轨迹，最后一分钟门前抢断冲刺全场绝杀，还有跟隔壁班踢球打进的小角度，当然也有很多很多无奈的时候，哈哈哈哈门前拿到绝胜球大好空间没有传球，打了小角度带全队失败，还有一次又一次射门错失，那时候的我对于每个球都计较的很，季林常常给我安慰鼓励。刚上大学感觉大家都蛮厉害啊，然后新生杯因为防守问题漏了一个乌龙，永远的自卑起来。但究竟是什么时候，自己在球场上都丢失了勇气呢。</p>
<p>关于研究生，原本理想化的是保研，但因为差了个做到，就无望了。后来想的是考研，但我最近崩的让我怀疑自己，我考研是为了什么呢？是过渡焦虑还是想要去到更高的平台。总在担心自己什么什么不会，其实个人来说，专注更为可贵？好好做完一件事吧。</p>
<p>听着秋田版本的曾经我也想过一了百了，放空自己瞎打出这些话，好像思路稍微理清了一点，不论未来要成为什么人，先做好事情，对吧，别说空话了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>第一天</title>
    <url>/2020/05/16/%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>换来换去发现还是比较喜欢这个风格，之后可以自己写一个就更好了。</p>
<p>还发现了一只可以存在博客里的小狗，想起来高中的自己对于计算机的一大向往就是能自己写一个桌面人物 “C.C.”，这个一定要努力实现啊。</p>
<p>博客以后就主要放整理的题解，各方面的踩坑，还有很多自言自语的话，也许还会有书单？</p>
<p>忘了在哪看到的，少看与自己无关的，少发与别人无关的，这里是自己的地方，就更自由了吧。</p>
<p>下周就是考试，几个科目好像都不怎么样，就先不做这些了，欠的东西还有很多，记着补。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>贝塔函数和伽马函数</title>
    <url>/2020/07/13/%E8%B4%9D%E5%A1%94%E5%87%BD%E6%95%B0%E5%92%8C%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>牛客一的 J 题我们先是想组合数，后面自己推公式做的，积分都好久没碰了所以耽误了很久，看到大家都秒了太强啦。赛后听人说除了查OEIS外，还有个贝塔函数的东西，附带加个伽马函数，分别是欧拉第一、第二积分。</p>
<ul>
<li><h5 id="贝塔函数"><a href="#贝塔函数" class="headerlink" title="贝塔函数"></a>贝塔函数</h5><p>对于任意实数 $P,Q&gt;0$,  $B（a,b）=\int_0^1x^{a-1}*(1-x)^{b-1}dx$</p>
<p>满足对称性:  $B(a,b)=B(b,a)$</p>
<p>$a,b$ 同为自然数时， $B(a,b)=\frac{(a-1)!*(b-1)!}{(a+b-1)!}$</p>
<p>$a,b$ 同为正整数时， $B(a,b)=\frac{a+b}{ab C_{a+b}^{a}} =\frac{1}{bC_{a+b-1}^{a-1} }$</p>
</li>
<li><h5 id="伽马函数"><a href="#伽马函数" class="headerlink" title="伽马函数"></a>伽马函数</h5><p>实数域 $α&gt;0$ , $Γ(α)=\int_0^{+∞}x^{α-1}e^{-x}dx$ ，另一种写法  $Γ(x)=2\int_0^{+∞}t^{2x-1}e^{-t^2}dt$</p>
<p>对于 $x∈(0,1)$ , $Γ(1-x)Γ(x)=\frac{Π}{sin{Πx}}$</p>
<p>$Γ(α+1)=αΓ(α)$  ,  $Γ(1)=1$  ,  $Γ(\frac{1}{2})=\sqrtΠ$   ,  $Γ(n+1)=n!$</p>
<a id="more"></a>

<img src="/2020/07/13/%E8%B4%9D%E5%A1%94%E5%87%BD%E6%95%B0%E5%92%8C%E4%BC%BD%E9%A9%AC%E5%87%BD%E6%95%B0/1.png" style="zoom: 67%;">
</li>
<li><h5 id="两者联系"><a href="#两者联系" class="headerlink" title="两者联系"></a>两者联系</h5><p>$B(a,b)=\frac{Γ(a)Γ(b)}{Γ(a+b)}$   $a+b=1$时，即 $B(a,1-a)=Γ(a)Γ(1-a)$</p>
</li>
<li><h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p>之后找些类似的典型题目做一下</p>
<p>昨天的 J 题  $\int_0^1(x-x^2)^ndx=\int_0^1x^n(1-x)^ndx$ </p>
<p>由贝塔函数： $B（a,b）=\int_0^1x^{a-1}<em>(1-x)^{b-1}dx$ ,$B(a,b)=\frac{(a-1)!</em>(b-1)!}{(a+b-1)!}$</p>
<p>可知 $a-1=n,b-1=n$ ，则公式为 $I = \frac{(n!)^2}{(2n-1)!}$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>对偶图-狼抓兔子</title>
    <url>/2020/07/14/%E5%AF%B9%E5%81%B6%E5%9B%BE-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="最小割-对偶图最短路"><a href="#最小割-对偶图最短路" class="headerlink" title="最小割=对偶图最短路"></a>最小割=对偶图最短路</h5><p>处理最小割问题时，考虑到时限，可以转为对偶图做</p>
<p>来道例题 <a href="https://www.luogu.com.cn/problem/P4001" target="_blank" rel="noopener">狼抓兔子</a></p>
<p>题意：封锁一条边的花费等于流量，问最小花费使得左上角无法到达右下角</p>
<img src="/2020/07/14/%E5%AF%B9%E5%81%B6%E5%9B%BE-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90/1.png">

<a id="more"></a>

<p>最直观的做法就是最大流求最小割，不过数据加强了之后时限有点不允许（谜之优化可以过</p>
<p> 题目所给是平面图，可以转成对偶图看一下，至于构造看下图（有亿点点丑</p>
<img src="/2020/07/14/%E5%AF%B9%E5%81%B6%E5%9B%BE-%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90/2.png" style="zoom:67%;">

<p>原本求S-&gt;T，将S和T加一条边，就多了一个面，对应的点为 T ‘ , 令该面与原无限面不连边，然后就是图中的蓝色线路，构造无向图，每条边的权值即其通过边的流量，因为S ‘-&gt;T ’ 正好隔断了S-&gt;T，且整张图经过了所有的边，所以我们只需要求 S ‘ -&gt; T ‘ ，就是原图的最小割。</p>
<p>回到该题目，同理构造一下对偶图，一定要注意开的点数和边数范围。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">10</span>; <span class="comment">//点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">6e6</span>+<span class="number">10</span>; <span class="comment">//边数 双向要开2倍</span></span><br><span class="line"><span class="keyword">int</span> w[M],e[M],ne[M];</span><br><span class="line"><span class="keyword">int</span> h[N],dis[N];</span><br><span class="line"><span class="keyword">int</span> idx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span> &gt; PII;</span><br><span class="line"><span class="keyword">int</span> n , m;</span><br><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> S[<span class="number">2020</span>][<span class="number">2020</span>];</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u , <span class="keyword">int</span> v , <span class="keyword">int</span> ww)</span></span>&#123;</span><br><span class="line">    e[idx]=v,w[idx]=ww,ne[idx]=h[u],h[u]=idx++;</span><br><span class="line">    e[idx]=u,w[idx]=ww,ne[idx]=h[v],h[v]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII ,<span class="built_in">vector</span>&lt;PII &gt;,greater&lt;PII &gt; &gt;heap;</span><br><span class="line">    heap.push(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        PII t = heap.top() ;</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">int</span> cur = t.second, distance=t.first;</span><br><span class="line">        <span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[cur] ; i != <span class="number">-1</span> ; i = ne[i] )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dis[j]&gt;distance+w[i])&#123;</span><br><span class="line">                dis[j]=distance+w[i];</span><br><span class="line">                heap.push(&#123;dis[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dis[T]==<span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dis[T];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.push(<span class="number">0</span>);</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vis[tmp] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[tmp]; i!=<span class="number">-1</span>; i=ne[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> o=e[i];</span><br><span class="line">            <span class="comment">//cout&lt;&lt;o&lt;&lt;" ";</span></span><br><span class="line">            <span class="keyword">if</span>(dis[o] &gt; dis[tmp] + w[i]) &#123;</span><br><span class="line">                dis[o] = dis[tmp] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!vis[o]) q.push(o), vis[o] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[T];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>),<span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,w);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w;</span><br><span class="line">            ans=<span class="built_in">max</span>(ans,w);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n<span class="number">-2</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            S[i][j]=++tot; <span class="comment">//订编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T=tot+<span class="number">1</span>;<span class="comment">// S为0 T为n+1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w;</span><br><span class="line">            <span class="keyword">int</span> u=S[i*<span class="number">2</span><span class="number">-1</span>][j];<span class="comment">//结点</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;</span><br><span class="line">                add(u,T,w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">                u=S[(i*<span class="number">2</span>)<span class="number">-2</span>][j];</span><br><span class="line">                add(<span class="number">0</span>,u,w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> v=S[(i*<span class="number">2</span>)<span class="number">-2</span>][j];</span><br><span class="line">                add(u,v,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> u=S[i*<span class="number">2</span>][j];</span><br><span class="line">                add(<span class="number">0</span>,u,w); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==m)&#123;</span><br><span class="line">                <span class="keyword">int</span> u=S[i*<span class="number">2</span><span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                add(u,T,w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> u=S[i*<span class="number">2</span><span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">int</span> v=S[i*<span class="number">2</span>][j];</span><br><span class="line">                add(u,v,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> w;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;w;</span><br><span class="line">            <span class="keyword">int</span> u=S[i*<span class="number">2</span>][j];</span><br><span class="line">            <span class="keyword">int</span> v=S[i*<span class="number">2</span><span class="number">-1</span>][j];</span><br><span class="line">            add(u,v,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dijkstra()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;SPFA()&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
</search>
